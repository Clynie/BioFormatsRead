# -*- coding: utf-8 -*-

from mpl_toolkits.mplot3d import axes3d
from matplotlib import cm
import matplotlib.pyplot as plt
import numpy as np


def filterplanetable(planetable, ImageID =0, T=0, Z=0, CH=0):

    # TODO - Implement smart filtering without creating an itermediate table

    # filter planetable for specific imageID
    if ImageID > planetable['ImageID'].max():
        print 'ImageID was invalid. Using ImageID = 0.'
        CH = 0
    pt = planetable[planetable['ImageID'] == ImageID]

    # filter planetable for specific timepoint
    if T > planetable['TheT'].max():
        print 'Time Index was invalid. Using T = 0.'
        CH = 0
    pt = planetable[planetable['TheT'] == T]

    # filter resulting planetable pt for a specific z-plane
    if Z > planetable['TheZ'].max():
        print 'Z-Plane Index was invalid. Using Z = 0.'
        zplane = 0
    pt = pt[pt['TheZ'] == Z]

    # filter planetable for specific channel
    if CH > planetable['TheC'].max():
        print 'Channel Index was invalid. Using CH = 0.'
        CH = 0
    pt = planetable[planetable['TheC'] == CH]

    # return filtered planetable
    return pt


def scatterplot(planetable, ImageID=0, T=0, Z=0, CH=0, size=35, savefigure=False, filename='test.png', showsurface=True):
    """

    This function can be used to visualize al XYZ positions from an image file for
    the selcted channel and zplane as a scatterplot.

    :param planetable: XYZ planetable generated by bftools.get_planetable
    :param ImageID: zero-based ImageID indes (image series inside BioFormats)
    :param T: zero-based timepoint Index
    :param Z: zero-based zplane index
    :param CH: zero-based channel index
    :param size: maker size used to plot all YX positions
    :param savefigure: boolean
    :param filename: filename to save the figure as PNG
    :param showsurface: displays the surface as 3D plot
    :return: Plot and optional save figure as PNG
    """

    ptf = filterplanetable(planetable, ImageID=0, T=0, Z=0, CH=0)

    # extract XYZ position for the selected channel
    xpos = ptf['XPos']
    ypos = ptf['YPos']
    zpos = ptf['ZPos']

    # normalize z-data
    zpos_norm = zpos - zpos.min()

    # delta xy for plotting the coordinate system in [micron]
    delta = 3000
    if xpos.min() - delta < 0:
        xmin = 0
    else:
        xmin = xpos.min()
    if ypos.min() - delta < 0:
        ymin = 0
    else:
        ymin = ypos.min()

    fig1 = plt.figure(figsize=(10, 6), dpi=100)
    ax1 = fig1.add_subplot(111)
    ax1.grid(True)
    plt.axis('equal')
    # set the plot limits
    ax1.set_xlim(0, xpos.max() + delta)
    ax1.set_ylim(0, ypos.max() + delta)
    # invert the Y-axis --> O,O = Top-Left
    ax1.invert_yaxis()
    # define the labels
    ax1.set_title('XYZ-Positions (norm) : ' + 'ImageID=' + str(ImageID) + ' T=' + str(T) + ' Z='+ str(Z) + ' CH=' + str(CH))
    ax1.set_xlabel('Stage X-Axis [micron]')
    ax1.set_ylabel('Stage Y-Axis [micron]')
    # plot data and label the colorbar
    sc = plt.scatter(xpos, ypos, marker='s', c=zpos_norm, s=size, cmap=cm.coolwarm)
    cb = plt.colorbar(sc)
    cb.set_label('Z-Offset [micron]', labelpad=20)

    # optional save figure as PNG
    if savefigure:
        savename = filename[:-4] + '_XYZ-Pos' + str(CH) + '.png'
        fig1.savefig(savename)

    # optional 3D plot of surface
    if showsurface:

        fig2 = plt.figure(figsize=(10, 6), dpi=100)
        ax2 = fig2.add_subplot(111, projection='3d')
        ax2.plot(xpos, ypos, zpos_norm, '.', markersize=10)
        # set the plot limits
        ax2.set_xlim(0, xpos.max() + delta)
        ax2.set_ylim(0, ypos.max() + delta)
        # invert the Y-axis --> O,O = Top-Left
        ax2.invert_yaxis()